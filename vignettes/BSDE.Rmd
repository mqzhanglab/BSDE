---
title: "An Introduction to BSDE"
author: "Mengqi Zhang, Richard Guo"
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo=TRUE, cache = !TRUE, warning = FALSE, 
  message = FALSE, cache.lazy = FALSE
)
runcode=!FALSE

library("BSDE")
```

# Introduction

This markdown includes two parts. 

The first parts gives a pure guide for the core usage of BSDE. 

The second part includes an example usage of BSDE on real data analysis.The second parts also includes the DE analysis with the [MAST](https://www.bioconductor.org/packages/release/bioc/html/MAST.html) packages(for scRNAseq) and the [DESeq2](https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html) packages(for bulk RNAseq) for comparison. This markdown is for individual case-control study based on Barycenter and Wasserstein distance estimation on the gene differential expression (DE) analysis of certain cell type based on simulated scRNAseq data from zero-inflated negative binomial (ZINB) distribution. 

# Installation

BSDE can be installed through githubs.
```{r install,eval=!runcode}
install.packages("devtools")
library(devtools)
install_github("mqzhanglab/BSDE")
```

# Part I: Pure instruction for BSDE

The core function from BSDE is cal_w2_pval. It calculates the p-values gene by gene, in most situation, the log-transformed genes are recommended for a better estimation.

cal_w2_pval has the following parameters, while the **count_per_gene**,  **meta_individual** and **meta_phenotype** are three required input.

**count_per_gene** is a len x 1 matrix,length=cell num.  It represents gene count.
**meta_individual** is a len x 1 vector, length=cell num. It represents individual labels.
**meta_phenotype** is a len x 1 vector, length=cell num. It is indicator labels (contains 0,1) for cases (1) and controls(0)
**perm_num** is a ingeter for times of permutation.
**merge_method** provides the support package for barycenter calculation, the default setting is based on the python package 'ot'(merge_method="python"), if python doesn't work, the R package merge_method="R" is also available
**unif_round_unit** is the unit length for frequency calculation.
**l_fold** is a positive number, represents the fold-change to the parameter lamda for merge_method R, the **lambda** is the Non-negative regularization parameter (for small lambda the Barycenter is close to the EMD).
**weight** is a len x 1 vector, length=subjects num. It represents the importance for subjects.
**shrink** is a bool value. If True, the range with zero density will be removed, for more robust performance to extreme values and reduce the computational burden. Choose TRUE if there are some extereme high expressions.


This function return a list, which contains:
**pval**: a p-value, from the based on Monte Carlo Permutation Procedure.
**case_bc_ob**: a vectors contains the density of case subjects distribution of Barycenter
**ctrl_bc_ob**: a vectors contains the density of ctrl subjects distribution of Barycenter

For example.

```{r pure_example,eval=!runcode}
library("BSDE")
library("reticulate")
library("doRNG")
count_per_gene=c(rpois(60,6),c(rpois(60,4)))
meta_individual=paste0("ind",rep(1:12,each=10))
meta_phenotype=c(rep(1,60),rep(0,60))
BSDE::cal_w2_pval(count_per_gene,meta_individual,meta_phenotype )
```



# Part II: An example for data analysis application on simulated datasets

Here we present a demo version of our simulation here, which are minimized and based on the DCA output of the 10% autism dataset with top 100 expressed genes.

In this simulation example, we will generate 30 genes from a particular type of cell of 20 case subjects and 20 control subjects, with each subjects have 100 cells. We simulate the basic parameters, i.e., the mean, dispersion and dropout parameter from the distribution of the real reference scRNAseq database from paper [Single-cell genomics identifies cell type–specific molecular changes in autism](https://science.sciencemag.org/content/364/6441/685.abstract).

Within this 30 genes, we simulate 4 different type of DEs by adding on particular ratios to the basic parameters to get expected fold changes, the rest genes are simulated without size factors and as controls

(1). mean DE: 3 genes are DE in mean but not in var (size factor 1.2).
(2).var DE: 3 genes are DE in var but not mean(size factor 1.2).
(3).multimodality DE: 3 genes are DE due to Multimodality (size factor 0.6).
(4).disp DE: 3 genes are DE in dispersion (size factor 0.2).

Please see our [simulation guide](https://github.com/mqzhanglab/BSDE/tree/main/simulation) for more details. 
```{r meta_simulation,eval=runcode}
sim_matrix=readRDS("../data/simulated/sim_matrix_1.2_1.2_0.6_0.2.rds")
sim_matrix_bulk=readRDS("../data/simulated/sim_matrix_bulk_1.2_1.2_0.6_0.2.rds")
meta=readRDS("../data/simulated/sim_meta_1.2_1.2_0.6_0.2.rds")
```


## Differential Expressed Analysis
We calculate the p-values of the simulated genes through the BSDE method as well as the [MAST](https://www.bioconductor.org/packages/release/bioc/html/MAST.html) (with a widely used protocol mixed-effect model "glmer" & Likelihood-ratio Test) and the [DESeq2](https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html).

## DESeq2

For DESeq2 analysis, we construct the bulk RNAseq situation though suming up the counts per gene, per cluster, per individual, per 1000 cells.

```{r deseq2,eval=runcode}
library("DESeq2")
cur_info = meta[, c("individual", "phenotype")]
cur_info = unique(cur_info)
rownames(cur_info) = cur_info$individual
cur_info$phenotype = as.factor(cur_info$phenotype)

# object construction
dds = DESeqDataSetFromMatrix(countData = sim_matrix_bulk,
                             colData = cur_info,
                             design = ~ phenotype)

# observed pvalue calculation
dds = DESeq(dds)
deseq_pval = results(dds)$pvalue
```

## MAST

We take the method of current usage of MAST, we get the p-values based on the Hurdle model ("H" model)
```{r MAST,eval=runcode}
library("MAST")
library("lme4")

sim_matrix_log = log2(1 + sim_matrix) #log transformed data

dim(sim_matrix_log)
sim_matrix_log[1:2, 1:5]

cell_id = colnames(sim_matrix_log)   #get the cell id from the data
gene_id = rownames(sim_matrix_log)   #get the gene id from the data

fData = data.frame(primerid = gene_id)
cData = data.frame(wellKey = cell_id)

diagnosis = as.character(meta$phenotype) #

diagnosis2=matrix("Control",ncol=1,nrow=length(diagnosis))
diagnosis2[which(diagnosis == "1")] = "Case"
diagnosis= as.factor(diagnosis2)

sca = MAST::FromMatrix(sim_matrix_log, cData, fData)
colData(sca)$cngeneson = as.numeric(meta$CDR)
colData(sca)$diagnosis = as.factor(diagnosis)
colData(sca)$ind = as.factor(meta$individual)

colData(sca)

print(date())
print(gc())
b1 = tryCatch(MAST::zlm(formula = ~ diagnosis + ( 1 | ind ), sca = sca, method = 'glmer', ebayes = FALSE, parallel = TRUE), error = function(e) {NA} )
print(date())
print(gc())

lrt1 = tryCatch(MAST::lrTest(b1, "diagnosis"), error = function(e) {NA} )
MAST_pval1 = tryCatch(apply(lrt1, 1, function(x){x[3,3]}), error = function(e) {NA} )
print(date())
print(gc())


```

## BSDE
We also calculate the p-values using the BSDE as follows.The major command for BSDE is cal_w2_pval. The required information includes

```{r BSDE,eval=runcode}
library("BSDE")

op_pval = matrix(ncol = 1, nrow = nrow(sim_matrix_log))

print(date())
print(gc())

for (i_g in 1:nrow(sim_matrix_log)) {
  cur_sim = sim_matrix_log[i_g, ]
  cur_ind = meta$individual
  cur_pheno = meta$phenotype
  
  op_pval[i_g] = tryCatch({
    cal_w2_pval(
      count_per_gene = cur_sim,
      meta_individual = cur_ind,
      meta_phenotype = cur_pheno,
      perm_num = 500,
      unif_round_unit = 0.5
    )[[1]]
  }, error = function(e) {
    NA
  })
}
print(date())
print(gc())

rownames(op_pval) = gene_id

```

## Further Analysis and Method Evaluation
Once we have the p-values, we can do further analysis on the method evaluation.For example, we can calculate the proportion of p-values < 0.05. We can also draw similar plot for power, where power is calculated as the proportion of p-values < 0.05 in permuted data. 

# Session Information
```{r ,eval=runcode}
sessionInfo()
```

# Reference


Finak, G., McDavid, A., Yajima, M., Deng, J., Gersuk, V., Shalek, A. K., ... & Gottardo, R. (2015). MAST: a flexible statistical framework for assessing transcriptional changes and characterizing heterogeneity in single-cell RNA sequencing data. Genome biology, 16(1), 1-13.

Love, M. I., Huber, W., & Anders, S. (2014). Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2. Genome biology, 15(12), 1-21.

Velmeshev, D., Schirmer, L., Jung, D., Haeussler, M., Perez, Y., Mayer, S., ... & Kriegstein, A. R. (2019). Single-cell genomics identifies cell type–specific molecular changes in autism. Science, 364(6441), 685-689.
